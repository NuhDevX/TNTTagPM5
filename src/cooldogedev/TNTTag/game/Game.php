<?php

/**
 *
 * Copyright (c) 2022 cooldogedev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @auto-license
 */

declare(strict_types=1);

namespace cooldogedev\TNTTag\game;

use cooldogedev\TNTTag\async\directory\AsyncDirectoryClone;
use cooldogedev\TNTTag\async\directory\AsyncDirectoryDelete;
use cooldogedev\TNTTag\game\data\GameData;
use cooldogedev\TNTTag\game\handler\EndHandler;
use cooldogedev\TNTTag\game\handler\IHandler;
use cooldogedev\TNTTag\game\handler\PreStartHandler;
use cooldogedev\TNTTag\game\player\PlayerManager;
use cooldogedev\TNTTag\session\Session;
use cooldogedev\TNTTag\TNTTag;
use cooldogedev\TNTTag\utility\message\KnownMessages;
use cooldogedev\TNTTag\utility\message\LanguageManager;
use cooldogedev\TNTTag\utility\message\TranslationKeys;
use pocketmine\player\Player;
use pocketmine\world\Explosion;
use pocketmine\world\World;

final class Game
{
    /**
     * For identifying worlds generated by the plugin.
     * can be used for things such as cleaning up the worlds during startup.
     */
    public const GAME_WORLD_IDENTIFIER = "TT-GAME-";
    public const GAME_LOBBY_IDENTIFIER = "TT-GAME-LOBBY-";

    protected ?PlayerManager $playerManager;
    protected ?IHandler $handler;

    protected ?Player $winner = null;
    protected ?World $world = null;
    protected ?World $lobby = null;
    protected int $round = 0;
    protected bool $deathMatch = false;
    protected bool $loading = true;

    public function __construct(protected TNTTag $plugin, protected ?GameData $data)
    {
        $this->playerManager = new PlayerManager($this);
        $this->handler = new PreStartHandler($this);

        $directories = [];

        $directories[$plugin->getDataFolder() . "maps" . DIRECTORY_SEPARATOR . $this->getData()->getName() . DIRECTORY_SEPARATOR . GameData::GAME_DATA_WORLD] = $plugin->getServer()->getDataPath() . "worlds" . DIRECTORY_SEPARATOR . $this->data->getWorld();

        if ($this->hasSeparateLobby()) {
            $directories[$this->plugin->getDataFolder() . "maps" . DIRECTORY_SEPARATOR . $this->getData()->getName() . DIRECTORY_SEPARATOR . GameData::GAME_DATA_LOBBY] = $plugin->getServer()->getDataPath() . "worlds" . DIRECTORY_SEPARATOR . $this->data->getLobby();
        }

        $task = new AsyncDirectoryClone($directories);
        $task->setClosure(
            function () use (&$plugin): void {
                if ($plugin->getServer()->getWorldManager()->loadWorld($this->data->getWorld())) {
                    $this->world = $plugin->getServer()->getWorldManager()->getWorldByName($this->data->getWorld());
                    $this->world->setSpawnLocation($this->world->getSpawnLocation()->add(0.5, 0, 0.5));
                } else {
                    $plugin->getLogger()->debug("Failed to load world " . $this->data->getWorld() . " of arena " . $this->getData()->getId());
                    $this->startDestruction();

                    return;
                }

                if ($this->hasSeparateLobby() && $plugin->getServer()->getWorldManager()->loadWorld($this->data->getLobby())) {
                    $this->lobby = $plugin->getServer()->getWorldManager()->getWorldByName($this->data->getLobby());
                    $this->lobby->setSpawnLocation($this->lobby->getSpawnLocation()->add(0.5, 0, 0.5));
                } else {
                    $plugin->getLogger()->debug("Failed to load lobby " . $this->data->getLobby() . " of arena " . $this->getData()->getId() . " used the game world as the lobby: " . $this->data->getWorld());
                    $this->lobby = $this->world;
                }

                $this->loading = false;
                $this->playerManager->clearQueue();
            }
        );

        $plugin->getServer()->getAsyncPool()->submitTask($task);
    }

    public function getData(): GameData
    {
        return $this->data;
    }

    public function getWorld(): ?World
    {
        return $this->world;
    }

    public function hasSeparateLobby(): bool
    {
        return strtolower($this->data->getLobby()) !== strtolower($this->data->getWorld()) && file_exists($this->plugin->getDataFolder() . "maps" . DIRECTORY_SEPARATOR . $this->getData()->getName() . DIRECTORY_SEPARATOR . GameData::GAME_DATA_LOBBY);
    }

    public function getLobby(): ?World
    {
        return $this->lobby;
    }

    public function startDestruction(): void
    {
        foreach ($this->playerManager->getSessions(null) as $session) {
            $this->playerManager->removeFromGame($session);
        }

        $this->plugin->getGameManager()->removeGame($this->getData()->getId());
        $this->world !== null && $this->plugin->getServer()->getWorldManager()->unloadWorld($this->world, true);

        $directories = [];
        $directories[] = $this->plugin->getServer()->getDataPath() . "worlds" . DIRECTORY_SEPARATOR . $this->data->getWorld();

        if ($this->hasSeparateLobby()) {
            $this->lobby !== null && $this->plugin->getServer()->getWorldManager()->unloadWorld($this->lobby, true);
            $directories[] = $this->plugin->getServer()->getDataPath() . "worlds" . DIRECTORY_SEPARATOR . $this->data->getLobby();
        }

        $task = new AsyncDirectoryDelete($directories);

        // Copy the id because we set the data to null afterwards.
        $id = $this->getData()->getId();
        $task->setClosure(fn() => $this->plugin->getLogger()->debug("Deleted tt-" . $id . " game."));
        $this->plugin->getServer()->getAsyncPool()->submitTask($task);

        $this->handler = null;
        $this->playerManager = null;
        $this->world = null;
        $this->winner = null;
        $this->data = null;
        $this->round = 0;
        $this->loading = true;
        $this->deathMatch = false;
    }

    public function getPlugin(): TNTTag
    {
        return $this->plugin;
    }

    public function isFree(bool $fromQueue = false): bool
    {
        if (
            !$this->handler instanceof PreStartHandler ||
            count($this->playerManager->getSessions()) >= $this->getData()->getMaxPlayers() ||
            $fromQueue && count($this->playerManager->getQueues()) >= $this->getData()->getMaxPlayers()
        ) {
            return false;
        }
        return true;
    }

    public function isLoading(): bool
    {
        return $this->loading;
    }

    public function getWinner(): ?Player
    {
        return $this->winner;
    }

    public function setWinner(?Player $winner): void
    {
        $this->winner = $winner;
    }

    public function explodePlayer(Session $session, bool $fromExplosion = false): void
    {
        if (count($this->playerManager->getSessions()) < 2) {
            return;
        }

        $position = clone $session->getPlayer()->getPosition();

        $this->getPlayerManager()->removeFromGame($session, spectate: true);

        $session->addLoss(1);
        $session->setWinStreak(0);

        $session->getPlayer()->sendTitle(LanguageManager::translate(LanguageManager::getMessage(KnownMessages::TOPIC_LOSE, KnownMessages::LOSE_TITLE)), LanguageManager::getMessage(KnownMessages::TOPIC_LOSE, KnownMessages::LOSE_SUBTITLE));
        $session->getPlayer()->sendMessage(LanguageManager::translate(LanguageManager::getMessage(KnownMessages::TOPIC_LOSE, KnownMessages::LOSE_MESSAGE)));

        $this->broadcastMessage(LanguageManager::translate(LanguageManager::getMessage(KnownMessages::TOPIC_TAGGED, KnownMessages::TAGGED_EXPLODE), [
            TranslationKeys::PLAYER => $session->getPlayer()->getDisplayName(),
        ]));

        if ($fromExplosion) {
            return;
        }

        $explosion = new Explosion($position, $this->plugin->getConfig()->get("behaviour")["explosion-radius"]);

        $explosion->explodeB();
    }

    public function getPlayerManager(): ?PlayerManager
    {
        return $this->playerManager;
    }

    public function broadcastMessage(string $message, array $replacement = [], ?int $mode = null): void
    {
        $sessions = $this->getPlayerManager()->getSessions($mode);

        foreach ($sessions as $session) {
            $session->getPlayer()->sendMessage(LanguageManager::translate($message, $replacement));
        }
    }

    public function tickGame(): void
    {
        if ($this->loading) {
            return;
        }

        if (count($this->getPlayerManager()->getSessions()) < 2 && !$this->handler instanceof EndHandler && !$this->handler instanceof PreStartHandler) {
            $this->broadcastTitle(LanguageManager::getMessage(KnownMessages::TOPIC_END, KnownMessages::END_TITLE), LanguageManager::getMessage(KnownMessages::TOPIC_END, KnownMessages::END_SUBTITLE), mode: Session::PLAYER_STATE_SPECTATOR);
            $this->broadcastMessage(LanguageManager::getMessage(KnownMessages::TOPIC_END, KnownMessages::END_MESSAGE), mode: Session::PLAYER_STATE_SPECTATOR);

            $this->broadcastTitle(LanguageManager::getMessage(KnownMessages::TOPIC_WIN, KnownMessages::WIN_TITLE), LanguageManager::getMessage(KnownMessages::TOPIC_WIN, KnownMessages::WIN_SUBTITLE), mode: Session::PLAYER_STATE_ALIVE);
            $this->broadcastMessage(LanguageManager::getMessage(KnownMessages::TOPIC_WIN, KnownMessages::WIN_MESSAGE), mode: Session::PLAYER_STATE_ALIVE);

            $session = $this->getPlayerManager()->getSessions()[array_key_first($this->getPlayerManager()->getSessions())];

            $session?->addWin(1);
            $session?->addWinStreak(1);

            $this->setWinner($session?->getPlayer());

            $session !== null && $this->getPlayerManager()->removeFromGame($session, spectate: true);

            $this->setHandler(new EndHandler($this));

            return;
        }

        $this->getHandler()?->handleScoreboardUpdates();
        $this->getHandler()?->handleTicking();
    }

    public function broadcastTitle(string $message, string $subtitle = "", array $replacement = [], ?int $mode = null, int $fadeIn = 5, int $stay = 20, int $fadeOut = 5): void
    {
        $sessions = $this->getPlayerManager()->getSessions($mode);

        foreach ($sessions as $session) {
            $session->getPlayer()->sendTitle(LanguageManager::translate($message, $replacement), LanguageManager::translate($subtitle, $replacement), $fadeIn, $stay, $fadeOut);
        }
    }

    public function getHandler(): ?IHandler
    {
        return $this->handler;
    }

    public function setHandler(IHandler $handler): void
    {
        $this->handler = $handler;
    }

    public function getRound(): int
    {
        return $this->round;
    }

    public function incrementRound(): void
    {
        $this->round++;
    }

    /**
     * @return Session[]
     */
    public function getTagged(): array
    {
        $sessions = [];
        foreach ($this->playerManager->getSessions() as $session) {
            if (!$session->isTagged()) {
                continue;
            }
            $sessions[] = $session;
        }
        return $sessions;
    }

    /**
     * @return Session[]
     */
    public function getRunners(): array
    {
        $sessions = [];
        foreach ($this->playerManager->getSessions() as $session) {
            if ($session->isTagged()) {
                continue;
            }
            $sessions[] = $session;
        }
        return $sessions;
    }

    public function isDeathMatch(): bool
    {
        return $this->deathMatch;
    }

    public function setDeathMatch(bool $deathMatch): void
    {
        $this->deathMatch = $deathMatch;
    }
}
